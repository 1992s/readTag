effective java:

​	21th:  用函数对象（function object）表示策略  声明一个接口表示策略，为每个具体 策略声明实现该接口的类，典型的如：comparator

​	注意：匿名类每次调用时都会创建一个新的对象，当我们要多次使用该策略的时候，可以将其策略作为静态成员变量，以便复用

​     **22th: 优先考虑静态成员类**

​	嵌套类（定义在类内部的类）：静态成员类，内部类（非静态成员类，匿名类，局部类）

​	Map接口使用非静态成员类实现集合视图，由keySet，entrySet，Values返回

​	Set,List使用非静态成员类实现他们的迭代器

​	如果成员类不要求访问外围的实例，应该将其声明为static class  ，因为非静态的成员类会保存外围对象的引用，会造成资源的浪费，同时在垃圾回收时也不会被清除，因为非静态成员类的实例必须拥有一个外围类的实例。

​	私有静态成员类：Map的Entry,如果是声明为非静态，那么entry的没有个实例要包含一个map的引用，那么必将造成资源的浪费。

​	如果一个嵌套类需要在方法之外仍然可见，或者太长的时候，就应该使用成员类。如果这个嵌套类必须要拥有外围类的实例，那么就使用非静态的嵌套类。反之，做成静态的。如果一个嵌套类属于方法的内部，只需要在一个地方创建实例，匿名类。其他的局部类。

​	**23th:不要在新代码中使用原生态类型**

​		泛型：声明中有一个或者多个类型参数的就是泛型list<E>,Map<String,Object>

​		原生态类型：List,Map (可以添加任意类型的元素，并且失去了泛型在安全性和表述性上面的优势)

​		在不确定或者不关心是的类型参数的时候可以用 无限制的通配符类型 ? .如 Set<?>,

​	**无法猜测会使用哪种类型的对象，无法接受这些现实，可以使用 泛型方法，或者有限制的通配符**

​	例外(都是因为类型擦除)：1.不能使用List<String.class> 或者List<String>.class,必须使用List.class  2. 不能使用 instanceof  如果要用 可以使用 if(o instanceof Set){Set<?> m = (Set<?> o)}

 

| 术语       | 示例                              | 所在条目 |
| -------- | ------------------------------- | ---- |
| 参数化的类型   | List<string>                    |      |
| 实际参数类型   | String                          |      |
| 泛型       | List<E>                         |      |
| x形式类型参数  | E                               |      |
| 无限制通配符类型 | List<?>                         |      |
| 原生态类型    | List                            |      |
| 有限制类型参数  | <E extends Number>              |      |
| 递归类型现实   | <T extends Comparable<T>>       |      |
| 有限制通配符类型 | List<? extends Number>          |      |
| 泛型方法     | static<E> List<E> asList<E[] a) |      |





**《设计模式之禅》**

​	原则：单一职责，

​		单一职责：有且只有一个原因可以是类改变，同时也可以提高复用性。接口一定要做到单一职责，类的设计尽量做到只有一个原因让他变化

​		里氏替换原则：如果对每一个类型为S的对象o1,都有类型为T的o2，使得T定义的所有程序P在所有对象o1s都换成o2时，程序p的行为没有发生变化，那么类型S是类型T的子类型。所有引用基类的地方必须能透明使用其子类的对象。

​		尽量避免子类的“个性化”，一旦子类有个性，这个子类和弗雷之间的关系就很难调和，把子类当做父类使用，子类的个性被抹杀；把子类单独作为一个业务来使用，就会让代码间的耦合关系变得扑朔迷离--缺乏替换的标准。

​		依赖倒置原则：高层不依赖低层模块，两者都依赖与抽象；抽象不应该以来与细节，细节应该依赖于抽象。在java语言中，抽象就是指接口或者抽象类；细节就是实现类，

​		三种写法：构造函数传递以来对象，setter传递以来对象，接口声明依赖对象

​		最佳实践：每个类尽量都有接口或者抽象类，变量的便面类型尽量使接口或者是抽象类，任何类都不应该从具体类派生。尽量不要覆写基类的方法。结合里氏替换原则。

​	1.单一职责原则

​	

​		

