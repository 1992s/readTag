设计模式

​	有**变化**的地方需要使用封装，比如要实现一个代理，我们目前使用的是jdk的动态代理，但是有可能以后我们会使用cglib的代理，所以我们需要将代理抽象成一个接口，以后变化的时候也可以不用变更其他的代码，只需要扩展接口就行了。

​	**另外：开闭原则是solid原则的基础，所有其他的设计模式的原则都是围绕着开闭原则展开的，可以说其他的五个原则都是开闭原则的一种事项方式。**





effective java: 	

​	**24th:消除非受检警告：**

​		当我们使用SuppressWarnings("unchecked")来禁止编译器的警告，就必须要把认为代码安全的原因注释下来。所以我们应该尽量避免出现这种不安全警告。可以使用Set<String> strSet = new HashSet<String>();这样来避免。

​     **25th:列表优于数组**

​	数组和泛型相比，数组是协变的即Sub与Base可以替换，但是泛型不一样，List<String>和List<Long>是不一样的。如Object[] arr = new Long[1];如果在运行时添加一字符串类型的元素，就会报错。但是泛型就不会，因为泛型在编译器就已经检查到了这个错误。

  注：创建泛型数组是非法的，如new E[].new List<String>[]

​	数组是协变且可以具体化的，泛型是不可变的而且可以被擦除的。因此数组提供了运行时的类型安全，但是没有编译时的类型安全。泛型则反之。

​	**26th:优先考虑泛型**

​		没咋看懂

​	



java 的151建议《》: 看到哪儿就记到哪儿

​	1.java的Arrays.asList产生的List是不可变的 就是不能操作产生List

​	2.显示地声明UID，当两个类的Uid一致的时候可以提高类的序列化和反序列化的兼容性

​	3.避免在可以序列化的类中使用构造函数为final变量赋值。因为反序列化的时候，构造函数不会执行。

​	4。实现Serializable接口的时候实现两个私有方法：writeObject,readObject可以控制序列化和反序列化的过程。

​	5.switch中的没有case后面都应该跟上break；

​	6.断言的使用，1.在对外公开的方法中不可使用断言，在输入校验中最好不要使用断言，特别是公开方法。如：一个方法的参数是String类型的，但是这个string的内容有限制，调用方并不知道这个情况，所以在这个方法里面使用断言是不合适的。2.在执行逻辑代码的时候也不可使用断言。

​	使用断言的地方：按照正常执行逻辑不可能到达的代码区域可以使用assert。如：在私有方法中使用assert做参数校验，流程控制中不可能到达的区域（？），建立程序探针（？）

​		